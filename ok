    params = {
        "n_estimators": trial.suggest_int("n_estimators", 100, 1000),
        "learning_rate": trial.suggest_float("learning_rate", 1e-3, 0.3, log=True),
        "num_leaves": trial.suggest_int("num_leaves", 20, 150),
        "max_depth": trial.suggest_int("max_depth", 3, 15),
        "min_child_samples": trial.suggest_int("min_child_samples", 5, 100),
        "subsample": trial.suggest_float("subsample", 0.5, 1.0),
        "colsample_bytree": trial.suggest_float("colsample_bytree", 0.5, 1.0),
        "reg_alpha": trial.suggest_float("reg_alpha", 0.0, 10.0),
        "reg_lambda": trial.suggest_float("reg_lambda", 0.0, 10.0),
        "random_state": 42,
        "n_jobs": -1  # ðŸ‘‰ parallÃ©lisation
    }


params = {
    "loss": trial.suggest_categorical("loss", ["log_loss", "hinge", "modified_huber", "squared_hinge"]),
    "penalty": trial.suggest_categorical("penalty", ["l1", "l2", "elasticnet"]),
    "alpha": trial.suggest_float("alpha", 1e-6, 1e-1, log=True),
    "l1_ratio": trial.suggest_float("l1_ratio", 0.0, 1.0),  # pour elasticnet
    "learning_rate": trial.suggest_categorical("learning_rate", ["constant", "optimal", "invscaling", "adaptive"]),
    "eta0": trial.suggest_float("eta0", 1e-3, 1.0, log=True),  # learning rate initial
    "max_iter": trial.suggest_int("max_iter", 100, 2000),
    "tol": trial.suggest_float("tol", 1e-5, 1e-2, log=True),
    "epsilon": trial.suggest_float("epsilon", 1e-3, 1e-1, log=True),  # pour loss insensitive
    "power_t": trial.suggest_float("power_t", 0.1, 0.9),  # pour invscaling
    "class_weight": "balanced",  # fixe pour fraude
    "random_state": 42,
    "n_jobs": -1
}
